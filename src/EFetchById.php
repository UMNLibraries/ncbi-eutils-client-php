<?php

namespace UmnLib\Core\NcbiEUtilsClient;

use UmnLib\Core\ArgValidator;

class EFetchById
{
  // Generated by NCBI: EFetch queries need either these or an id param.
  //protected $query_key;
  //protected $WebEnv;
  protected $ids;

  //  e.g. 'umn-lib-extractor'
  protected $tool;

  //  TODO: other possibilities than 'citation'?
  protected $rettype;

  //  TODO: other possibilities than 'xml'?
  protected $retmode;

  // These are parameters to send on every search request.
  protected $commonParams;

  protected $db;
  protected $email;
  protected $fileSet;
  protected $eutil;

  function __construct(Array $args)
  {
    $validatedArgs = ArgValidator::validate(
      $args,
      array(
        'ids' => array('is' => 'array'),
        'email' => array('is' => 'string'),
        'db' => array('is' => 'string', 'default' => 'pubmed'),
        'tool' => array('is' => 'string'),
        'rettype' => array('is' => 'string', 'default' => 'citation'),
        'retmode' => array('is' => 'string', 'default' => 'xml'),
        'commonParams' => array('is' => 'array', 'default' => array('email','db','tool','rettype','retmode')),
        'fileSet' => array('instanceof' => '\UmnLib\Core\File\Set\DateSequence'),
        'eutil' => array(
          'instanceof' => '\UmnLib\Core\NcbiEutilsClient\EUtil',
          'builder' => function () { return new \UmnLib\Core\NcbiEUtilsClient\EUtil(array('format' => 'raw', 'util' => 'fetch')); },
        ),
      )
    );

    foreach ($validatedArgs as $property => $value) {
      $this->$property = $value;
    }
  }

  public function fetch()
  {
    // output
    $filenames = array();

    $ids = $this->ids();
    $count = count($ids);

    $offset = 0;
    // TODO: Make length, i.e. number of records per download, configurable!
    $length = 500;

    while ($offset <= ($count-1)) {
      unset($result, $e, $filename, $file, $params, $idsSlice);

      $idsSlice = array_slice($ids, $offset, $length);
      $params['id'] = join(',', $idsSlice);
      foreach ($this->commonParams() as $param) {
        $params[$param] = $this->$param();
      }

      try {
        $result = $this->eutil()->sendRequest($params);
      } catch (\Exception $e) {
        error_log($e->getMessage());
      }
      if (!isset($e)) {
        $filename = $this->fileSet()->add(); 
        file_put_contents($filename, $result);
        $filenames[] = $filename;
      }
      $offset += $length;
    }
    return $filenames;
  }

  /**
   * @internal
   *           
   * Implements accessor methods.
   *                     
   * @param string $function The function/method name must be the same as the name of the property being accessed.
   * @param array $args Ignored and optional, since we implement only accessors here.
   * @return mixed The value of the property named by $function.
   */
  function __call($function, $args)
  {
    // Since we're handling only accessors here, the function name should
    // be the same as the property name:
    $property = $function;
    $class = get_class($this);
    $refClass = new \ReflectionClass($class);
    if (!$refClass->hasProperty($property)) {
      throw new \RuntimeException("Method '$function' does not exist in class '$class'.");
    }
    return $this->$property;
  }
}
